remove kth element of the linkedList 

brute force approach inpython 
class Node:
    def __init__(self,data):
        self.data=data
        self.next=None
def delete_kth_bruteforce(head,k):
    if not head:
        return None 
    arr=[]
    curr=head
    while curr:
        arr.append(curr.data)
        curr=curr.next
    if k<=0 or k>len(arr):
        return head
    arr.pop(k-1)
    dummy=Node(0)
    curr=dummy
    for val in arr:
        curr.next=Node(val)
        curr=curr.next
    return dummy.next
def print_list(head):
    curr = head
    while curr:
        print(curr.data, end=" -> ")
        curr = curr.next
    print("None")
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head = delete_kth_bruteforce(head, 3)
print_list(head)

java brute force approach in java 
class Node{
    int data;
    Node next;
    Node(int data){
        this.data=data;
    }
}
public class DeleteKthElement{
    public static Node deleteKthBruteForce(Node head,Int k){
        int head==null{
            return null;
        }
        java.util.List<Integer> arr=new java.util.Arraylist<>();
        Node curr=head;
        while curr!=null{
            arr.add(curr.data);
            curr=curr.next;
        }
        if(k<=0 || k>arr.size()){
            return head;
        }
        arr.remove(k-1);
        node dummy=new Node(0);
        curr=dummy;
        for(int val:arr){
            curr.next=new Node(val);
            curr=curr.next;
        }
        return dummy.next;

    }
    public static void printListNode(Node head){
        Node curr=head;
        while(curr!=null){
            System.out.print(curr.data+"->");
            curr=curr.next;
        }
        System.out.println("null");

    }
    public static void main(String[] args){
        Node head=new Node(1);
        head.next=new Node(2);
        head.next.next=Node(3);
        head.next.next.next=Node(4);
        head = deleteKthBruteForce(head, 3);
        printList(head);
    }
}

2. better approach in python 
def delete_kth_node_better(head):
    if not head:
        return None
    if k==1:
        return head.next
    curr=head
    for _ in range(k-2):
        if not curr.next:
            return head
        curr=curr.next
    if curr.next:
        curr.next=curr.next.next
    return head

better in java 
public static Node deleteKthElement(Node head,int k){
    if(head==null){
        return null;
    }
    if k==1{
        return head.next;
    }
    Node curr=head;
    for(int i=0;i<k-2;i++){
        if(curr.next==null){
            return head;

        }
        curr=curr.next;
    }
    if(curr.next!=null){
        curr.next=curr.next.next;

    }
    return head;
}

3. optimal approach in python 
def delete_kth_element(head):
    if k<=0 or not head:
        return head
    if k==1:
        return head.next
    prev,curr=None,head
    count=1
    while curr and count<k:
        prev=curr
        curr=curr.next
        count+=1
    if curr;
        prev.next=curr.next
    return head

optimal java 
public static Node deletekthElement(Node head,int k){
    if(k<=0 || head==null){
        return head;
    }
    if(k==1){
        return head.next;
    }
    Node prev=null, curr=head;
    int count=1;
    while(curr != null && count<k){
        prev=curr;
        curr=curr.next;
        count++;
    }
    if (curr!=null){
        prev.next=curr.next;
    }
    return head;
}
        
